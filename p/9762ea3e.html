<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.liuvv.com",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1,dimmer:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.json"}</script><meta name="description" content="1. 非锁定和锁定一致性读1.1 非锁定一致性读(普通select，mvcc)就是普通的 SELECT 语句(没有加锁后缀)， innodb 不会加锁， 就算别人锁了你也可以读。InnoDB存储引擎通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，Inno"><meta name="keywords" content="mysql"><meta property="og:type" content="article"><meta property="og:title" content="mysql的锁和事务机制"><meta property="og:url" content="https://www.liuvv.com/p/9762ea3e.html"><meta property="og:site_name" content="Levon&#39;s Blog"><meta property="og:description" content="1. 非锁定和锁定一致性读1.1 非锁定一致性读(普通select，mvcc)就是普通的 SELECT 语句(没有加锁后缀)， innodb 不会加锁， 就算别人锁了你也可以读。InnoDB存储引擎通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，Inno"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.liuvv.com/p/9762ea3e/2.png"><meta property="og:image" content="https://www.liuvv.com/p/9762ea3e/1.png"><meta property="og:image" content="https://www.liuvv.com/p/9762ea3e/3.png"><meta property="og:image" content="https://www.liuvv.com/p/9762ea3e/4.png"><meta property="og:updated_time" content="2024-04-12T09:22:51.958Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="mysql的锁和事务机制"><meta name="twitter:description" content="1. 非锁定和锁定一致性读1.1 非锁定一致性读(普通select，mvcc)就是普通的 SELECT 语句(没有加锁后缀)， innodb 不会加锁， 就算别人锁了你也可以读。InnoDB存储引擎通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，Inno"><meta name="twitter:image" content="https://www.liuvv.com/p/9762ea3e/2.png"><link rel="canonical" href="https://www.liuvv.com/p/9762ea3e.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>mysql的锁和事务机制 | Levon's Blog</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?521e5dbc31dd12bb9431823008da3dfc";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Levon's Blog</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">微信: L6241425</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>日志</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/unix2dos" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.liuvv.com/p/9762ea3e.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="levon"><meta itemprop="description" content="Keep it simple, stupid."></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Levon's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">mysql的锁和事务机制</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-04-07 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-07T00:00:00+08:00">2022-04-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-04-12 17:22:51" itemprop="dateModified" datetime="2024-04-12T17:22:51+08:00">2024-04-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/3-计算机系统/" itemprop="url" rel="index"><span itemprop="name">3-计算机系统</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/3-计算机系统/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a> </span></span><span id="/p/9762ea3e.html" class="post-meta-item leancloud_visitors" data-flag-title="mysql的锁和事务机制" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/p/9762ea3e.html#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/p/9762ea3e.html" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>11k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>10 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="1-非锁定和锁定一致性读"><a href="#1-非锁定和锁定一致性读" class="headerlink" title="1. 非锁定和锁定一致性读"></a>1. 非锁定和锁定一致性读</h1><h3 id="1-1-非锁定一致性读-普通select，mvcc"><a href="#1-1-非锁定一致性读-普通select，mvcc" class="headerlink" title="1.1 非锁定一致性读(普通select，mvcc)"></a>1.1 非锁定一致性读(普通select，mvcc)</h3><p>就是普通的 SELECT 语句(没有加锁后缀)， innodb 不会加锁， 就算别人锁了你也可以读。</p><p>InnoDB存储引擎通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB存储引擎会去读取行的一个快照数据。</p><a id="more"></a> <img src="/p/9762ea3e/2.png" alt="1" style="zoom:40%"><p>非一致性读，因为不需要等待访问的行上X锁的释放。快照数据是指该行的之前版本的数据，该实现是通过undo段来完成。此外，读取快照数据是不需要上锁的，极大地提高了数据库的并发性。</p><p>快照数据其实就是当前行数据之前的历史版本，每行记录可能有多个版本。由此带来的并发控制，称之为多版本并发控制（Multi Version Concurrency Control，MVCC）。</p><h3 id="1-2-RC-和-RR-非一致性读区别"><a href="#1-2-RC-和-RR-非一致性读区别" class="headerlink" title="1.2 RC 和 RR 非一致性读区别"></a>1.2 RC 和 RR 非一致性读区别</h3><p>在事务隔离级别READ COMMITTED和REPEATABLE READ（InnoDB存储引擎的默认事务隔离级别）下，InnoDB存储引擎使用非锁定的一致性读。然而，对于快照数据的定义却不相同<strong>。</strong></p><p>在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。而在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</p><ul><li>session A</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT*FROM parent WHERE id=1;</span><br><span class="line"></span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li>session B</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE parent SET id=3 WHERE id=1;</span><br></pre></td></tr></table></figure><p>在会话 B 中将事务表 parent 中 id 为 1 的记录修改为 id=3，但是事务同样没有提交，这样 id=1 的行其实加了一个 X 锁。</p><p>回到之前的会话 A，接着上次未提交的事务，执行 SQL 语句 <code>SELECT*FROM parent WHERE id=1</code> 的操作，这时不管使用 READ COMMITTED 还是 REPEATABLE READ 的事务隔离级别，显示的数据应该都是 1。</p><ul><li>session A</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT*FROM parent WHERE id=1;</span><br><span class="line"></span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li>session B</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit</span><br></pre></td></tr></table></figure><p>在会话 B 提交事务后，这时在会话 A 中再运行 <code>SELECT*FROM parent WHERE id=1</code> 的 SQL 语句。<br>对于 READ COMMITTED 的事务隔离级别，它总是读取行的最新版本。（其他事务修改后的值，读到的是NULL，因而被修改了）<br>对于 REPEATABLE READ 的事务隔离级别，总是读取事务开始时的行数据。（当前事务最初的值，读到的还是1）</p><h3 id="1-3-锁定一致性读（select后面加锁语法查询）"><a href="#1-3-锁定一致性读（select后面加锁语法查询）" class="headerlink" title="1.3 锁定一致性读（select后面加锁语法查询）"></a>1.3 锁定一致性读（select后面加锁语法查询）</h3><p>即使是对于SELECT的只读操作。InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读（locking read）操作：</p><ul><li><p>SELECT…FOR UPDATE</p></li><li><p>SELECT…LOCK IN SHARE MODE</p></li></ul><p>SELECT…FOR UPDATE 对读取的行记录加一个 X 锁，其他事务不能对已锁定的行加上任何锁。SELECT…LOCK IN SHARE MODE 对读取的行记录加一个 S 锁，其他事务可以向被锁定的行加 S 锁，但是如果加 X 锁，则会被阻塞。</p><p>SELECT…FOR UPDATE，SELECT…LOCK IN SHARE MODE必须在一个事务中，当事务提交了，锁也就释放了。因此在使用上述两句SELECT锁定语句时，务必加上BEGIN，START TRANSACTION或者SET AUTOCOMMIT=0。</p><h1 id="2-Mysql的锁"><a href="#2-Mysql的锁" class="headerlink" title="2. Mysql的锁"></a>2. Mysql的锁</h1><h3 id="2-1-不同数据库的锁实现"><a href="#2-1-不同数据库的锁实现" class="headerlink" title="2.1 不同数据库的锁实现"></a>2.1 不同数据库的锁实现</h3><p>对于MyISAM引擎，其锁是表锁设计。并发情况下的读没有问题，但是并发插入时的性能就要差一些了。</p><p>Microsoft SQL Server开始支持乐观并发和悲观并发，在乐观并发下开始支持行级锁，但是其实现方式与InnoDB存储引擎的实现方式完全不同。用户会发现在Microsoft SQL Server下，锁是一种稀有的资源，锁越多开销就越大，因此它会有锁升级。在这种情况下，行锁会升级到表锁，这时并发的性能又回到了以前。</p><h3 id="2-2-行锁"><a href="#2-2-行锁" class="headerlink" title="2.2 行锁"></a>2.2 行锁</h3><p>InnoDB 存储引擎实现了如下两种标准的行级锁：</p><ul><li><p>共享锁（S Lock），允许事务读一行数据。( select…lock in share mode)</p></li><li><p>排他锁（X Lock），允许事务删除或更新一行数据。( select…for update)</p></li></ul><p>如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁，因为读取并没有改变行r的数据，称这种情况为锁兼容（Lock Compatible）。但若有其他的事务T3想获得行r的排他锁，则其必须等待事务T1、T2释放行r上的共享锁——这种情况称为锁不兼容。</p><p>X 锁与任何的锁都不兼容，而 S 锁仅和 S 锁兼容。需要特别注意的是，S 和 X 锁都是行锁，兼容是指对同一记录（row）锁的兼容性情况。</p><h3 id="2-3-意向锁（和其他锁可共存）"><a href="#2-3-意向锁（和其他锁可共存）" class="headerlink" title="2.3 意向锁（和其他锁可共存）"></a>2.3 意向锁（和其他锁可共存）</h3><p>InnoDB存储引擎支持多粒度（granular）锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称之为意向锁（Intention Lock）。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度（fine granularity）上进行加锁。</p><p>InnoDB存储引擎支持意向锁设计比较简练，其意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：</p><p>1）意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁</p><p>2）意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁</p><img src="/p/9762ea3e/1.png" alt="1" style="zoom:40%"><p>若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。</p><p>例如图6-3，如果需要对页上的记录r进行上X锁，那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上X锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。举例来说，在对记录r加X锁之前，已经有事务对表1进行了S表锁，那么表1上已存在S锁，之后事务需要对记录r在表1上加上IX，由于不兼容，所以该事务需要等待表锁操作的完成。</p><h3 id="2-4-行锁和意向锁的兼容"><a href="#2-4-行锁和意向锁的兼容" class="headerlink" title="2.4 行锁和意向锁的兼容"></a>2.4 行锁和意向锁的兼容</h3><table><thead><tr><th>锁</th><th>类别</th><th>使用</th></tr></thead><tbody><tr><td>共享锁 (S 锁)</td><td>行锁(读锁)</td><td>select * from table where id = 1 lock in share mode;</td></tr><tr><td>排它锁 (X 锁)</td><td>行锁(写锁)</td><td>select * from table where id = 1 for update;</td></tr><tr><td>意向共享锁 (IS 锁)</td><td>表锁</td><td>数据引擎自己维护,用户无法手动操作</td></tr><tr><td>意向排他锁 (IX 锁)</td><td>表锁</td><td>数据引擎自己维护,用户无法手动操作</td></tr></tbody></table><ul><li>兼容性</li></ul><table><thead><tr><th></th><th>IS</th><th>IX</th></tr></thead><tbody><tr><td>IS</td><td>兼容</td><td>兼容</td></tr><tr><td>IX</td><td>兼容</td><td>兼容</td></tr></tbody></table><table><thead><tr><th></th><th>S</th><th>X</th></tr></thead><tbody><tr><td>IS</td><td>兼容</td><td>互斥</td></tr><tr><td>IX</td><td>互斥</td><td>互斥</td></tr></tbody></table><h3 id="2-5-锁升级"><a href="#2-5-锁升级" class="headerlink" title="2.5 锁升级"></a>2.5 锁升级</h3><p>InnoDB存储引擎不存在锁升级的问题。因为其不是根据每个记录来产生行锁的，相反，其根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式。因此不管一个事务锁住页中一个记录还是多个记录，其开销通常都是一致的。</p><p>假设一张表有300 0000个数据页，每个页大约有100条记录，那么总共有3 0000 0000条记录。若有一个事务执行全表更新的SQL语句，则需要对所有记录加X锁。若根据每行记录产生锁对象进行加锁，并且每个锁占用10字节，则仅对锁管理就需要差不多需要3GB的内存。</p><p>而InnoDB存储引擎根据页进行加锁，并采用位图方式，假设每个页存储的锁信息占用30个字节，则锁对象仅需90MB的内存。由此可见两者对于锁资源开销的差距之大。</p><h1 id="3-行锁算法"><a href="#3-行锁算法" class="headerlink" title="3.行锁算法"></a>3.行锁算法</h1><h3 id="3-1-行锁的-3-种算法"><a href="#3-1-行锁的-3-种算法" class="headerlink" title="3.1 行锁的 3 种算法"></a>3.1 行锁的 3 种算法</h3><p>InnoDB 存储引擎有 3 种行锁的算法，其分别是：</p><ul><li><p>Record Lock：单个行记录上的锁。</p></li><li><p>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。</p></li><li><p>Next-Key Lock∶ Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。</p></li></ul><p>Record Lock 总是会去锁住索引记录，如果 InnoDB 存储引擎表在建立的时候没有设置任何一个索引，那么这时 InnoDB 存储引擎会使用隐式的主键来进行锁定。</p><p>在Next-Key Lock算法下，InnoDB对于行的查询都是采用这种锁定算法。例如一个索引有10，11，13和20这四个值，那么该索引可能被Next-Key Locking的区间为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(-∞,10]</span><br><span class="line">(10,11]</span><br><span class="line">(11,13]</span><br><span class="line">(13，20]</span><br><span class="line">(20,+∞)</span><br></pre></td></tr></table></figure><p>当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。</p><p><strong>行锁举例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t(a <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">SELECT</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">SELECT</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> a = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">INSERT</span> INTOt <span class="keyword">SELECT</span> <span class="number">4</span>; <span class="comment"># 可以插入</span></span><br></pre></td></tr></table></figure><p>表t共有1、2、5三个值。在上面的例子中，在会话A中首先对a=5进行X锁定。而由于a是主键且唯一，因此锁定的仅是5这个值，这样在会话B中插入值4而不会阻塞，可以立即插入并返回。即锁定由Next-Key Lock算法降级为了Record Lock，从而提高应用的并发性。</p><p>Next-Key Lock降级为Record Lock仅在查询的列是唯一索引的情况下。若是辅助索引，则情况会完全不同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> z(a <span class="built_in">INT</span>,b <span class="built_in">INT</span>,PRIMARY <span class="keyword">KEY</span>(a),<span class="keyword">KEY</span>(b));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">1</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">3</span>,<span class="number">1</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">5</span>,<span class="number">3</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">7</span>,<span class="number">6</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">10</span>,<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">(-无穷,1](1,3](3,6](6,8](8,+无穷)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span>*<span class="keyword">FROM</span> z <span class="keyword">WHERE</span> b=<span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>由于有两个索引，其需要分别进行锁定。</p><p>对于聚集索引，其仅对列a等于5的索引加上Record Lock。而对于辅助索引，其加上的是Next-Key Lock，锁定的范围是(1，3)，特别需要注意的是，InnoDB存储引擎还会对辅助索引下一个键值加上gap lock，即还有一个辅助索引范围为(3，6)的锁。因此，若在新会话B中运行下面的SQL语句，都会被阻塞：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>*<span class="keyword">FROM</span> z <span class="keyword">WHERE</span> a=<span class="number">5</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>; <span class="comment"># 已经对聚集索引中列a=5的值加上X锁，因此执行会被阻塞。</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">4</span>,<span class="number">2</span>; <span class="comment"># 但是插入的辅助索引值2在锁定的范围(1，3)中，因此执行同样会被阻塞。</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">6</span>,<span class="number">5</span>; <span class="comment"># 插入的值5在另一个锁定的范围(3，6)中，故同样需要等待。</span></span><br></pre></td></tr></table></figure><p>而下面的SQL语句，不会被阻塞，可以立即执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">8</span>,<span class="number">6</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">2</span>,<span class="number">0</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">6</span>,<span class="number">7</span>;</span><br></pre></td></tr></table></figure><p><strong>间隙锁</strong></p><p>在InnoDB存储引擎中，对于INSERT的操作，其会检查插入记录的下一条记录是否被锁定，若已经被锁定，则不允许查询。对于上面的例子，会话A已经锁定了表z中b=3的记录，即已经锁定了(1，3)的范围，这时若在其他会话中进行如下的插入同样会导致阻塞：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>*<span class="keyword">FROM</span> z <span class="keyword">WHERE</span> b=<span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">2</span>,<span class="number">2</span>; <span class="comment"># 阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">2</span>,<span class="number">0</span>; <span class="comment"># 可以执行</span></span><br></pre></td></tr></table></figure><p>对于唯一键值的锁定，Next-Key Lock降级为Record Lock仅存在于查询所有的唯一索引列。若唯一索引由多个列组成，而查询仅是查找多个唯一索引列中的其中一个，那么查询其实是range类型查询，而不是point类型查询，故InnoDB存储引擎依然使用Next-Key Lock进行锁定。</p><h3 id="3-2-RR-用-Next-Key-Locking-解决幻读"><a href="#3-2-RR-用-Next-Key-Locking-解决幻读" class="headerlink" title="3.2 RR 用 Next-Key Locking 解决幻读"></a>3.2 RR 用 Next-Key Locking 解决幻读</h3><p>即 REPEATABLE READ 下，InnoDB 存储引擎采用 Next-Key Locking 机制来避免 Phantom Problem（幻像问题）。这点可能不同于与其他的数据库，如 Oracle 数据库，因为其可能需要在 SERIALIZABLE 的事务隔离级别下才能解决 Phantom Problem。</p><p>表 t 由 1、2、5 这三个值组成，对于 SQL 语句 <code>SELECT*FROM t WHERE a＞2 FOR UPDATE</code>，其锁住的不是 5 这单个值，而是对（2，+∞）这个范围加了 X 锁。因此任何对于这个范围的插入都是不被允许的，从而避免 Phantom Problem。</p><p>InnoDB存储引擎默认的事务隔离级别是REPEATABLE READ，在该隔离级别下，其采用Next-Key Locking的方式来加锁。而在事务隔离级别READ COMMITTED下，其仅采用Record Lock。</p><h1 id="4-事务问题"><a href="#4-事务问题" class="headerlink" title="4. 事务问题"></a>4. 事务问题</h1><h3 id="4-1-脏读"><a href="#4-1-脏读" class="headerlink" title="4.1 脏读"></a>4.1 脏读</h3><p>脏读指的就是在不同的事务下，当前事务可以读到另外事务未提交的数据，简单来说就是可以读到脏数据。违反了事务的隔离性。</p><p>脏读现象在生产环境中并不常发生，从上面的例子中就可以发现，脏读发生的条件是需要事务的隔离级别为READ UNCOMMITTED，而目前绝大部分的数据库都至少设置成READ COMMITTED。</p><h3 id="4-2-不可重复读（包扩幻读）"><a href="#4-2-不可重复读（包扩幻读）" class="headerlink" title="4.2 不可重复读（包扩幻读）"></a>4.2 不可重复读（包扩幻读）</h3><p>不可重复读是指在一个事务内多次读取同一数据集合，两次读到的数据是不一样的情况，这种情况称为不可重复读。其违反了数据库事务一致性的要求。</p><p>不可重复读和脏读的区别是：脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据（提交是指别的事务 commit）。</p><p>在 InnoDB 存储引擎中，通过使用 Next-Key Lock 算法来避免不可重复读的问题。在 MySQL 官方文档中将不可重复读的问题定义为 Phantom Problem，即幻像问题。</p><p>在 Next-Key Lock 算法下，对于索引的扫描，不仅是锁住扫描到的索引，而且还锁住这些索引覆盖的范围（gap）。因此在这个范围内的插入都是不允许的。这样就避免了另外的事务在这个范围内插入数据导致的不可重复读的问题。</p><p>因此，InnoDB存储引擎的默认事务隔离级别是READ REPEATABLE，采用Next-Key Lock算法，避免了不可重复读的现象。</p><h3 id="4-3-丢失更新（业务问题）"><a href="#4-3-丢失更新（业务问题）" class="headerlink" title="4.3 丢失更新（业务问题）"></a>4.3 丢失更新（业务问题）</h3><p>脏读，幻读，不可重复读是读的问题，丢失更新是写的问题。</p><p>mysql丢失更新问题英文叫lost update。指的是两个事务同时更新一条数据，后更新的覆盖了前面更新的结果，从结果上看第一次的更新丢失了的现象。</p><p>其实现在数据库本身并没有丢失更新的问题，因为当一个事务更新一条记录时，就会加排他锁，另外一个的更新就会阻塞住。所以丢失更新大多是业务本身的问题。（查出来数据，算后再改）</p><ul><li>悲观锁解决</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">// 所有的会话都并发执行这个SQL，只有一个可以获取 X 锁成功，其他的都等待</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, balance <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">// 假设返回：balance = 100，代码里 balance += 10;  balance = 110</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance = <span class="number">110</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><ul><li>调整更新策略解决</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">// 执行快照读</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, balance <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line">// 这个数据有可能会被其他的并发更新给修改掉，不一定是最新的数据</span><br><span class="line"></span><br><span class="line">// 执行<span class="keyword">update</span>操作，注意这里的不同，是直接对余额做 增/减 操作，</span><br><span class="line">//  利用一致性读视图在<span class="keyword">update</span>时执行当前读的特点，也就是说如果有多个会话执行 <span class="keyword">update</span>，其余的会被阻塞</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance = balance + <span class="number">10</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><h1 id="5-Mysql的事务"><a href="#5-Mysql的事务" class="headerlink" title="5. Mysql的事务"></a>5. Mysql的事务</h1><p>InnoDB存储引擎中的事务完全符合ACID的特性。ACID是以下4个词的缩写：</p><ul><li><p>原子性（atomicity）</p></li><li><p>一致性（consistency）</p></li><li><p>隔离性（isolation） // 锁主要解决的问题</p></li><li><p>持久性（durability)</p></li></ul><h3 id="5-1-事务分类"><a href="#5-1-事务分类" class="headerlink" title="5.1 事务分类"></a>5.1 事务分类</h3><p>对于InnoDB存储引擎来说，其支持扁平事务、带有保存点的事务、链事务、分布式事务。</p><ul><li>扁平事务（Flat Transaction）是事务类型中最简单的一种，但在实际生产环境中，这可能是使用最为频繁的事务。在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束，其间的操作是原子的，要么都执行，要么都回滚。</li><li>分布式事务（Distributed Transactions）通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。节点A不能通过调用一台数据库就完成任务。其需要访问网络中两个节点的数据库，而在每个节点的数据库执行的事务操作又都是扁平的。对于分布式事务，其同样需要满足ACID特性，要么都发生，要么都失效。</li></ul><h3 id="5-2-事务的实现"><a href="#5-2-事务的实现" class="headerlink" title="5.2 事务的实现"></a>5.2 事务的实现</h3><p>事务隔离性由锁来实现。原子性、一致性、持久性通过数据库的redo log和undo log来完成。redo log称为重做日志，用来保证事务的原子性和持久性。undo log用来保证事务的一致性。</p><p>有的DBA或许会认为undo是redo的逆过程，其实不然。redo和undo的作用都可以视为是一种恢复操作，redo恢复提交事务修改的页操作，而undo回滚行记录到某个特定版本。因此两者记录的内容不同，redo通常是物理日志，记录的是页的物理修改操作。undo是逻辑日志，根据每行记录进行记录。</p><h3 id="5-3-事务隔离级别"><a href="#5-3-事务隔离级别" class="headerlink" title="5.3 事务隔离级别"></a>5.3 事务隔离级别</h3><table><thead><tr><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>Read Uncommitted(RU)未提交读</td><td>不加锁</td></tr><tr><td>Read Committed(RC)已提交读</td><td>解决脏读</td></tr><tr><td>Repeatable Read(RR)可重复读</td><td>解决脏读，不可重复读，innodb 还解决了幻读(因为间隙锁不让别人插入)，默认级别</td></tr><tr><td>Serializable(SE) 串行化</td><td>select隐式转为lock in share mode, 会和 update,delete 互斥 解决脏读, 不可重复读, 幻读</td></tr></tbody></table><p>InnoDB存储引擎默认支持的隔离级别是REPEATABLE READ，但是与标准SQL不同的是，InnoDB存储引擎在REPEATABLE READ事务隔离级别下，使用Next-Key Lock锁的算法，因此避免幻读的产生。</p><p>这与其他数据库系统（如Microsoft SQL Server数据库）是不同的。所以说，InnoDB存储引擎在默认的REPEATABLE READ的事务隔离级别下已经能完全保证事务的隔离性要求，即达到SQL标准的SERIALIZABLE隔离级别。</p><p>隔离级别越低，事务请求的锁越少或保持锁的时间就越短。这也是为什么大多数数据库系统默认的事务隔离级别是READ COMMITTED。</p><h3 id="5-4-MySQL数据库分布式事务"><a href="#5-4-MySQL数据库分布式事务" class="headerlink" title="5.4 MySQL数据库分布式事务"></a>5.4 MySQL数据库分布式事务</h3><p>InnoDB存储引擎提供了对XA事务的支持，并通过XA事务来支持分布式事务的实现。在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为SERIALIZABLE。</p><p>XA事务由一个或多个资源管理器（Resource Managers）、一个事务管理器（Transaction Manager）以及一个应用程序（Application Program）组成。</p><ul><li>资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器。</li><li>事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信。</li><li>应用程序：定义事务的边界，指定全局事务中的操作。</li></ul><p>在MySQL数据库的分布式事务中，资源管理器就是MySQL数据库，事务管理器为连接MySQL服务器的客户端。图7-22显示了一个分布式事务的模型。</p><img src="/p/9762ea3e/3.png" alt="1" style="zoom:40%"><p>分布式事务使用两段式提交（two-phase commit）的方式。</p><p>在第一阶段，所有参与全局事务的节点都开始准备（PREPARE），告诉事务管理器它们准备好提交了。在第二阶段，事务管理器告诉资源管理器执行ROLLBACK还是COMMIT。如果任何一个节点显示不能提交，则所有的节点都被告知需要回滚。可见与本地事务不同的是，分布式事务需要多一次的PREPARE操作，待收到所有节点的同意信息后，再进行COMMIT或是ROLLBACK操作。</p><p><strong>Mysql内部XA事务</strong></p><p>最为常见的内部XA事务存在于binlog与InnoDB存储引擎之间。二进制日志和重做日志必须同时写入。若二进制日志先写了，而在写入InnoDB存储引擎时发生了宕机，那么slave可能会接收到master传过去的二进制日志并执行，最终导致了主从不一致的情况。</p><p>当事务提交时，InnoDB存储引擎会先做一个PREPARE操作，将事务的xid写入，接着进行二进制日志的写入，如图7-24所示。如果在InnoDB存储引擎提交前，MySQL数据库宕机了，那么MySQL数据库在重启后会先检查准备的UXID事务是否已经提交，若没有，则在存储引擎层再进行一次提交操作。</p><img src="/p/9762ea3e/4.png" alt="1" style="zoom:40%"><h1 id="6-log"><a href="#6-log" class="headerlink" title="6. log"></a>6. log</h1><h3 id="6-1-redo-log"><a href="#6-1-redo-log" class="headerlink" title="6.1 redo log"></a>6.1 redo log</h3><h5 id="1-redo-log-和-undo-log的区别"><a href="#1-redo-log-和-undo-log的区别" class="headerlink" title="1. redo log 和 undo log的区别"></a>1. redo log 和 undo log的区别</h5><p>redo log用来保证事务的持久性，undo log用来帮助事务回滚及MVCC的功能。redo log基本上都是顺序写的，在数据库运行时不需要对redo log的文件进行读取操作。而undo log是需要进行随机读写的。</p><h5 id="2-redo-log-和-bin-log的区别"><a href="#2-redo-log-和-bin-log的区别" class="headerlink" title="2. redo log 和 bin log的区别"></a>2. redo log 和 bin log的区别</h5><p>MySQL数据库中还有一种二进制日志（binlog），其用来进行POINT-IN-TIME（PIT）的恢复及主从复制（Replication）环境的建立。从表面上看其和重做日志非常相似，都是记录了对于数据库操作的日志。然而，从本质上来看，两者有着非常大的不同。</p><p>首先，重做日志是在InnoDB存储引擎层产生，而二进制日志是在MySQL数据库的上层产生的，并且二进制日志不仅仅针对于InnoDB存储引擎，MySQL数据库中的任何存储引擎对于数据库的更改都会产生二进制日志。</p><p>其次，两种日志记录的内容形式不同。MySQL数据库上层的二进制日志是一种逻辑日志，其记录的是对应的SQL语句。而InnoDB存储引擎层面的重做日志是物理格式日志，其记录的是对于每个页的修改。</p><h5 id="3-恢复"><a href="#3-恢复" class="headerlink" title="3. 恢复"></a>3. 恢复</h5><p>InnoDB存储引擎在启动时不管上次数据库运行时是否正常关闭，都会尝试进行恢复操作。因为重做日志记录的是物理日志，因此恢复的速度比逻辑日志，如二进制日志，要快很多。</p><p>INSERT操作在二进制日志中就不是幂等的，重复执行可能会插入多条重复的记录。而上述INSERT操作的重做日志是幂等的。</p><h3 id="6-2-undo-log"><a href="#6-2-undo-log" class="headerlink" title="6.2 undo log"></a>6.2 undo log</h3><p>用户通常对undo有这样的误解：undo用于将数据库物理地恢复到执行语句或事务之前的样子——但事实并非如此。</p><p>用户执行了一个INSERT 10W条记录的事务，这个事务会导致分配一个新的段，即表空间会增大。在用户执行ROLLBACK时，会将插入的事务进行回滚，但是表空间的大小并不会因此而收缩。因此，当InnoDB存储引擎回滚时，它实际上做的是与先前相反的工作。对于每个INSERT，InnoDB存储引擎会完成一个DELETE；对于每个DELETE，InnoDB存储引擎会执行一个INSERT；对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改前的行放回去。</p><p>除了回滚操作，undo的另一个作用是MVCC，即在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p><p>最后也是最为重要的一点是，undo log会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p><h1 id="7-头脑风暴"><a href="#7-头脑风暴" class="headerlink" title="7. 头脑风暴"></a>7. 头脑风暴</h1><ul><li>行锁包括共享锁 (lock in share mode)，排他锁（for update）</li><li>意向锁，和其他锁可以共存。本身也是一个表锁。</li><li>行锁三种算法：行记录锁, 间隙锁，next-key 锁（行 + 间）</li><li>脏读是读到其他未提交的数据。不可重复度能读到其他事务提交的数据（RR 通过快照读创建一次解决）。</li></ul><h1 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8. 参考资料"></a>8. 参考资料</h1><ul><li><a href="https://www.bilibili.com/video/BV1x54y1979n?from=search&seid=4833652458207423339" target="_blank" rel="noopener">MySQL事务和锁机制详解</a></li><li><a href="https://www.zhihu.com/question/51513268/answer/127777478" target="_blank" rel="noopener">https://www.zhihu.com/question/51513268/answer/127777478</a></li><li><a href="https://www.wencst.com/archives/1521" target="_blank" rel="noopener">https://www.wencst.com/archives/1521</a></li><li>索引 <a href="https://www.liuvv.com/p/84544518.html">https://www.liuvv.com/p/84544518.html</a></li></ul><ul><li>锁和事务 <a href="https://www.liuvv.com/p/9762ea3e.html">https://www.liuvv.com/p/9762ea3e.html</a></li><li>MVCC <a href="https://www.liuvv.com/p/a0f7945d.html">https://www.liuvv.com/p/a0f7945d.html</a></li></ul></div><div class="reward-container"><div>给作者打赏，可以加首页微信，咨询作者相关问题！</div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.jpg" alt="levon 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="levon 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/mysql/" rel="tag"># mysql</a></div><div class="post-nav"><div class="post-nav-item"><a href="/p/4ce15f73.html" rel="prev" title="OAuth2认证流程和授权模式"><i class="fa fa-chevron-left"></i> OAuth2认证流程和授权模式</a></div><div class="post-nav-item"><a href="/p/6aa20615.html" rel="next" title="linux零拷贝技术讲解">linux零拷贝技术讲解 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-非锁定和锁定一致性读"><span class="nav-text">1. 非锁定和锁定一致性读</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-非锁定一致性读-普通select，mvcc"><span class="nav-text">1.1 非锁定一致性读(普通select，mvcc)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-RC-和-RR-非一致性读区别"><span class="nav-text">1.2 RC 和 RR 非一致性读区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-锁定一致性读（select后面加锁语法查询）"><span class="nav-text">1.3 锁定一致性读（select后面加锁语法查询）</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Mysql的锁"><span class="nav-text">2. Mysql的锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-不同数据库的锁实现"><span class="nav-text">2.1 不同数据库的锁实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-行锁"><span class="nav-text">2.2 行锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-意向锁（和其他锁可共存）"><span class="nav-text">2.3 意向锁（和其他锁可共存）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-行锁和意向锁的兼容"><span class="nav-text">2.4 行锁和意向锁的兼容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-锁升级"><span class="nav-text">2.5 锁升级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-行锁算法"><span class="nav-text">3.行锁算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-行锁的-3-种算法"><span class="nav-text">3.1 行锁的 3 种算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-RR-用-Next-Key-Locking-解决幻读"><span class="nav-text">3.2 RR 用 Next-Key Locking 解决幻读</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-事务问题"><span class="nav-text">4. 事务问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-脏读"><span class="nav-text">4.1 脏读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-不可重复读（包扩幻读）"><span class="nav-text">4.2 不可重复读（包扩幻读）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-丢失更新（业务问题）"><span class="nav-text">4.3 丢失更新（业务问题）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Mysql的事务"><span class="nav-text">5. Mysql的事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-事务分类"><span class="nav-text">5.1 事务分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-事务的实现"><span class="nav-text">5.2 事务的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-事务隔离级别"><span class="nav-text">5.3 事务隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-MySQL数据库分布式事务"><span class="nav-text">5.4 MySQL数据库分布式事务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-log"><span class="nav-text">6. log</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-redo-log"><span class="nav-text">6.1 redo log</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-redo-log-和-undo-log的区别"><span class="nav-text">1. redo log 和 undo log的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-redo-log-和-bin-log的区别"><span class="nav-text">2. redo log 和 bin log的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-恢复"><span class="nav-text">3. 恢复</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-undo-log"><span class="nav-text">6.2 undo log</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-头脑风暴"><span class="nav-text">7. 头脑风暴</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-参考资料"><span class="nav-text">8. 参考资料</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="levon" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">levon</p><div class="site-description" itemprop="description">Keep it simple, stupid.</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">312</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">71</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">143</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/unix2dos" title="GitHub → https://github.com/unix2dos" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:levonfly@gmail.com" title="E-Mail → mailto:levonfly@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://twitter.com/levonfly" title="Twitter → https://twitter.com/levonfly" rel="noopener" target="_blank"><i class="twitter fa-fw"></i>Twitter</a> </span><span class="links-of-author-item"><a href="https://weibo.com/l6241425" title="Weibo → https://weibo.com/l6241425" rel="noopener" target="_blank"><i class="weibo fa-fw"></i>Weibo</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://coolshell.cn/" title="https://coolshell.cn/" rel="noopener" target="_blank">酷壳</a></li><li class="links-of-blogroll-item"><a href="https://io-oi.me/" title="https://io-oi.me/" rel="noopener" target="_blank">一休儿</a></li><li class="links-of-blogroll-item"><a href="https://catcoding.me/" title="https://catcoding.me/" rel="noopener" target="_blank">程序员的喵</a></li><li class="links-of-blogroll-item"><a href="https://eurychen.me/" title="https://eurychen.me/" rel="noopener" target="_blank">东泽煮粥</a></li><li class="links-of-blogroll-item"><a href="https://www.zsythink.net/" title="https://www.zsythink.net/" rel="noopener" target="_blank">朱双印</a></li><li class="links-of-blogroll-item"><a href="https://luanruisong.com/" title="https://luanruisong.com/" rel="noopener" target="_blank">anwu</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备20000727号 </a><img src="/images/beian.png" style="display:inline-block"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010502039978" rel="noopener" target="_blank">京公网安备11010502039978号</a></div><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">levon</span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var e,t,o,n,r,a=document.getElementsByTagName("link");if(0<a.length)for(i=0;i<a.length;i++)"canonical"==a[i].rel.toLowerCase()&&a[i].href&&(e=a[i].href);t=e?e.split(":")[0]:window.location.protocol.split(":")[0],e=e||window.location.href,window,n=e,r=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(n)||(o="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",r?(o+="?r="+encodeURIComponent(document.referrer),n&&(o+="&l="+n)):n&&(o+="?l="+n),(new Image).src=o)}()</script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'Y4ry1QHkYxVXKLQBrx6LJXld-gzGzoHsz',
      appKey     : 'TXITOypSvI7JO61NI8EG5exk',
      placeholder: "留下您的小脚丫吧~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});</script></body></html>